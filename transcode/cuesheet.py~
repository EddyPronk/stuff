# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime
import string

class cueScanner(runtime.Scanner):
    patterns = [
        ('\\s', re.compile('\\s')),
        ('END', re.compile('$')),
        ('NUM', re.compile('[0-9]+')),
        ('KEYWORD', re.compile('[A-Z]+')),
        ('STR', re.compile('"([^\\"]+|\\\\.)*"')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{'\\s':None,},str,*args,**kw)

class cue(runtime.Parser):
    Context = runtime.Context
    def track(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'track', [])
        KEYWORD = self._scan('KEYWORD', context=_context)
        _token = self._peek('NUM', 'STR', context=_context)
        if _token == 'NUM':
            NUM = self._scan('NUM', context=_context)
            return (KEYWORD, string.atoi(NUM))
        else: # == 'STR'
            STR = self._scan('STR', context=_context)
            return (KEYWORD, STR[1:-1])

    def sheet(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'sheet', [])
        result = []
        while self._peek('END', 'KEYWORD', context=_context) == 'KEYWORD':
            track = self.track(_context)
            result.append(track)
        END = self._scan('END', context=_context)
        return result


def parse(rule, text):
    P = cue(cueScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
